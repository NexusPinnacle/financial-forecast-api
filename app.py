from flask import Flask, request, jsonify, render_template, send_file
import pandas as pd
from io import BytesIO
from forecaster import generate_forecast
from flask_cors import CORS

app = Flask(
    __name__,
    template_folder='.',    
    static_folder='.',      
    static_url_path='/'     
)
CORS(app)

@app.route('/')
def home():
    return render_template('index.html')    

def get_inputs_from_request(data):
    """Helper function to parse and convert inputs from request data."""
    
    def get_list_float(key):
        list_str = data.get(key, [])
        if isinstance(list_str, str):
            list_str = [list_str]
        return [float(rate) for rate in list_str if rate is not None]

    inputs = {
        "initial_revenue": float(data.get('initial_revenue') or 0.0),
        "tax_rate": float(data.get('tax_rate') or 0.0),
        "initial_ppe": float(data.get('initial_ppe') or 0.0),
        "depreciation_rate": float(data.get('depreciation_rate') or 0.0),
        "initial_debt": float(data.get('initial_debt') or 0.0),
        "initial_cash": float(data.get('initial_cash') or 0.0),
        "interest_rate": float(data.get('interest_rate') or 0.0),
        "years": int(data.get('years', 3) or 3),
        
        # HYBRID UPDATE: Capture how many years are detailed as months
        "monthly_years": int(data.get('monthly_years', 1) or 1),
        
        # GRANULAR LISTS
        "revenue_growth_rates": get_list_float('revenue_growth_rates'),
        "cogs_pct_rates": get_list_float('cogs_pct_rates'),
        "fixed_opex_rates": get_list_float('fixed_opex_rates'),
        "capex_rates": get_list_float('capex_rates'),
        "dso_days_list": get_list_float('dso_days_list'),
        "dio_days_list": get_list_float('dio_days_list'),
        "dpo_days_list": get_list_float('dpo_days_list'),
        "annual_debt_repayment_list": get_list_float('annual_debt_repayment_list'),
    }
    
    return inputs

@app.route('/api/forecast', methods=['POST'])
def forecast():
    try:
        data = request.json
        inputs = get_inputs_from_request(data)
        # Pass inputs to the hybrid forecaster
        forecast_results = generate_forecast(**inputs)
        return jsonify(forecast_results)
    except Exception as e:
        import traceback
        app.logger.error(f"Forecast Error: {e}\n{traceback.format_exc()}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/export', methods=['POST'])
def export_to_excel():
    try:
        data = request.json
        inputs = get_inputs_from_request(data)
        forecast_results = generate_forecast(**inputs)

        output = BytesIO()
        writer = pd.ExcelWriter(output, engine='xlsxwriter')
        
        # HYBRID UPDATE: Use the dynamic Labels generated by the forecaster
        # bs_labels includes 'Start', is_cfs_labels excludes 'Start'
        bs_labels = forecast_results['Labels']
        is_cfs_labels = forecast_results['Labels'][1:]
        
        # Convert dictionaries to DataFrames using the dynamic timeline labels as columns
        df_is = pd.DataFrame(forecast_results['excel_is'], index=is_cfs_labels).T
        df_bs = pd.DataFrame(forecast_results['excel_bs'], index=bs_labels).T
        df_cfs = pd.DataFrame(forecast_results['excel_cfs'], index=is_cfs_labels).T
        
        df_is.index.name = 'Line Item'
        df_bs.index.name = 'Line Item'
        df_cfs.index.name = 'Line Item'
        
        # Export Sheets
        df_is.to_excel(writer, sheet_name='Income Statement', float_format='%.0f')
        df_bs.to_excel(writer, sheet_name='Balance Sheet', float_format='%.0f')
        df_cfs.to_excel(writer, sheet_name='Cash Flow Statement', float_format='%.0f')
        
        # Auto-formatting logic
        for sheet_name, df in [('Income Statement', df_is), ('Balance Sheet', df_bs), ('Cash Flow Statement', df_cfs)]:
            worksheet = writer.sheets[sheet_name]
            # Set the width of the Line Item column
            worksheet.set_column('A:A', 30)
            # Set the width of the data columns
            worksheet.set_column(1, len(df.columns), 14)

        writer.close()
        output.seek(0)
        
        return send_file(
            output, 
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            as_attachment=True,
            download_name='Hybrid_Financial_Forecast.xlsx'
        )

    except Exception as e:
        import traceback
        app.logger.error(f"Export Error: {e}\n{traceback.format_exc()}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
